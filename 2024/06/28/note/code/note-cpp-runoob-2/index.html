<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>runoob_cpp 笔记 (2): C++ 数据类型 | notanumbb's blog</title><meta name="author" content="notanumbb"><meta name="copyright" content="notanumbb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从 runoob 开始随手学 cpp (2)  介绍 C++ 的基本数据类型，常量，字符 &#x2F; 字符串，数组操作与自定义数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="runoob_cpp 笔记 (2): C++ 数据类型">
<meta property="og:url" content="http://example.com/2024/06/28/note/code/note-cpp-runoob-2/index.html">
<meta property="og:site_name" content="notanumbb&#39;s blog">
<meta property="og:description" content="从 runoob 开始随手学 cpp (2)  介绍 C++ 的基本数据类型，常量，字符 &#x2F; 字符串，数组操作与自定义数据结构">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/nisepanda_round.png">
<meta property="article:published_time" content="2024-06-28T06:56:45.000Z">
<meta property="article:modified_time" content="2024-07-08T07:05:22.221Z">
<meta property="article:author" content="notanumbb">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/nisepanda_round.png"><link rel="shortcut icon" href="/img/nisepanda_round_128.png"><link rel="canonical" href="http://example.com/2024/06/28/note/code/note-cpp-runoob-2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":false,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: false,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'runoob_cpp 笔记 (2): C++ 数据类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2024-07-08 15:05:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/nisepanda_round.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-anchor"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="notanumbb's blog"></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-anchor"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">runoob_cpp 笔记 (2): C++ 数据类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-06-28T06:56:45.000Z" title="发表于 2024-06-28 14:56:45">2024-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code/">code</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/code/cpp/">cpp</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"
/>
<br/>
<blockquote>
<p>笔记大量参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-tutorial.html">菜鸟教程</a>；</p>
</blockquote>
<p>这节介绍 C++ 中的数据类型：</p>
<ul>
<li>七种基础数据类型，修饰符，枚举类型与类型转换</li>
<li>变量作用域</li>
<li>C++ 常量</li>
<li>字符 / 字符串基本操作</li>
<li>数组，多维数组与数组指针</li>
<li>利用 <code>struct</code> 语句自定义数据结构</li>
</ul>
<br/>
<br/>
<hr>
<h2 id="2-1-基本操作">2.1 基本操作</h2>
<h3 id="七种基础数据类型">七种基础数据类型</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">布尔型</td>
<td style="text-align:left">bool (true, false (注意小写)</td>
</tr>
<tr>
<td style="text-align:left">字符型</td>
<td style="text-align:left">char</td>
</tr>
<tr>
<td style="text-align:left">整型</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">浮点型</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">双浮点型</td>
<td style="text-align:left">double</td>
</tr>
<tr>
<td style="text-align:left">无类型 (类型缺失)</td>
<td style="text-align:left">void</td>
</tr>
<tr>
<td style="text-align:left">宽字符型</td>
<td style="text-align:left">wchar_t</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其实 wchar_t 是这样来的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef short int wchar_t;</span><br></pre></td></tr></table></figure>
<p>也就是给 short int 类型取了个别名 ... 所以 wchar_t 实际上的空间是和 short int 一样。</p>
</blockquote>
<p>注意大部分的变量是没有初始值的，所以最好建议定义的时候就赋值搞定；且对于局部变量是不会自动赋值初始值的，下面几种类型的全局变量会有对应的初始值；</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">初始化默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">'\0'</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">pointer</td>
<td style="text-align:left">NULL</td>
</tr>
</tbody>
</table>
<p>多种基本类型也可以被如下多种修饰符修饰，<a href="xxx">详见修饰符章节</a>，其中比较常用的有：</p>
<ol>
<li>整数类型（Integer Types）：
<ul>
<li><code>int</code>：用于表示整数，通常占用4个字节。</li>
<li><code>short</code>：用于表示短整数，通常占用2个字节。</li>
<li><code>long</code>：用于表示长整数，通常占用4个字节。</li>
<li><code>long long</code>：用于表示更长的整数，通常占用8个字节。</li>
</ul>
</li>
<li>浮点类型（Floating-Point Types）：
<ul>
<li><code>float</code>：用于表示单精度浮点数，通常占用4个字节。</li>
<li><code>double</code>：用于表示双精度浮点数，通常占用8个字节。</li>
<li><code>long double</code>：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。</li>
</ul>
</li>
<li>字符类型（Character Types）：
<ul>
<li><code>char</code>：用于表示字符，通常占用1个字节。</li>
<li><code>wchar_t</code>：用于表示宽字符，通常占用2或4个字节。</li>
<li><code>char16_t</code>：用于表示16位Unicode字符，占用2个字节。</li>
<li><code>char32_t</code>：用于表示32位Unicode字符，占用4个字节。</li>
</ul>
</li>
</ol>
<br/>
<h3 id="左值与右值">左值与右值</h3>
<p>C++ 中有两种类型的表达式：</p>
<ul>
<li>**左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。</li>
<li>**右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
<p>比如说定义变量 <code>int a = 1;</code></p>
<ul>
<li>
<p>这里的 <code>a</code> 是指向一个开辟了的内存空间的，里面可以填入值，也可以重新赋值 <code>a = 2;</code>，同样可以出现在等号的右边 <code>int b = a</code>，属于左值；</p>
</li>
<li>
<p>而这里的 <code>1</code> 也就是一个存在地址中的数值 (存在了 <code>a</code> 指向的这一块内存空间中)，无法赋值，属于右值；</p>
</li>
</ul>
<br/>
<h3 id="修饰符">修饰符</h3>
<p>C++ 允许在 <strong>char、int 和 double</strong> 数据类型前放置修饰符，可以对默认的多种变量类型进行进一步的规定；</p>
<p>主要包括</p>
<table>
<thead>
<tr>
<th>title</th>
<th>explain</th>
<th>note</th>
</tr>
</thead>
<tbody>
<tr>
<td>signed</td>
<td>表示可以存储负数</td>
<td>可用于 int, char，也可以作为 short / long 的前缀</td>
</tr>
<tr>
<td>unsigned</td>
<td>表示仅支持非负数的存储</td>
<td>可用于 int, char，也可以作为 short / long 的前缀，unsigned int 可以简写为 unsigned (省略 int)</td>
</tr>
<tr>
<td>short</td>
<td>表示可以存储的范围比默认的 int 更小</td>
<td>可用于 int；short int 可以简写为 short (省略 int)</td>
</tr>
<tr>
<td>long</td>
<td>表示可以存储的范围比默认的 int 更大</td>
<td>可用于 int, double；long int 可以简写为 long (省略 int)</td>
</tr>
<tr>
<td>long long</td>
<td>表示可以存储的范围比默认的 long 更大</td>
<td>可用于 int</td>
</tr>
</tbody>
</table>
<p>举几个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> num1 = <span class="number">-10</span>; <span class="comment">// 定义有符号整型变量 num1，初始值为 -10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">20</span>; <span class="comment">// 定义无符号整型变量 num2，初始值为 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="type">int</span> num1 = <span class="number">10</span>; <span class="comment">// 定义短整型变量 num1，初始值为 10</span></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> num2 = <span class="number">100000</span>; <span class="comment">// 定义长整型变量 num2，初始值为 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> num1 = <span class="number">10000000000</span>; <span class="comment">// 定义长长整型变量 num1，初始值为 10000000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> num1 = <span class="number">3.14f</span>; <span class="comment">// 定义单精度浮点数变量 num1，初始值为 3.14</span></span><br><span class="line"><span class="type">double</span> num2 = <span class="number">2.71828</span>; <span class="comment">// 定义双精度浮点数变量 num2，初始值为 2.71828</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 定义布尔类型变量 flag，初始值为 true</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch1 = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 定义字符类型变量 ch1，初始值为 &#x27;a&#x27;</span></span><br><span class="line"><span class="type">wchar_t</span> ch2 = <span class="string">L&#x27;你&#x27;</span>; <span class="comment">// 定义宽字符类型变量 ch2，初始值为 &#x27;你&#x27;</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="自定义：重命名与枚举类型">自定义：重命名与枚举类型</h3>
<p>可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> type newname; </span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> feet; <span class="comment">// 将 feet 作为原来的内置类型 int 的新名字</span></span><br><span class="line">feet distance;    <span class="comment">// 创建一个类型为 feet (实际上就是 int) 的新变量，名为 distance</span></span><br></pre></td></tr></table></figure>
<p>另外地，用户可以通过枚举类型 <strong>enum</strong> 来定义一个 <strong>枚举类型</strong>，具体形式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum 枚举名&#123; </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">     标识符[=整型常数], </span><br><span class="line">... </span><br><span class="line">    标识符[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure>
<p>这里干了三件事：</p>
<ul>
<li>定义一个新的枚举类型 color，类型为 color 的变量可以有三种不同的取值，为 red，green，blue；</li>
<li>创建一个类型为 color 的新变量，c；</li>
<li>给 c 赋值为 color</li>
</ul>
<p>实际存储的时候，枚举类型的每一个选项都会被赋予一个常数值，通常情况下第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推；当然也可以在定义枚举类型的时候就为每一个选项指定一个常数值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green=<span class="number">5</span>, blue &#125;;</span><br></pre></td></tr></table></figure>
<p>此时 red 的值为 0 (从 0 开始，初始值)，而 green 的值为 5 (用户设定)</p>
<p>但是注意这里的 blue 的值会跟着变成 6，在为每一选项赋值的时候若未指定，系统会默认取名为前一选项 +1</p>
<br/>
<h3 id="类型转换">类型转换</h3>
<p>常用类型转换有如下几种方式：</p>
<ol>
<li><strong>静态转换 <code>static_cast</code></strong></li>
</ol>
<p>将一种数据类型的值强制转换为另一种数据类型的值</p>
<p>注意它只进行编译时的运行检查，而不进行任何运行时类型检查，因此可能会导致运行时错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtype new_var = <span class="built_in">static_cast</span>&lt;newtype&gt;(original_var);</span><br></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 静态将int类型转换为float类型</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>动态转换 <code>dynamic_cast</code></strong></li>
</ol>
<p>在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常</p>
<p>基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtype varname = dynamic_cast&lt;newtype&gt;(ori_type);</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); </span><br><span class="line"><span class="comment">// 将基类指针 (Base*) 转换为派生类指针 (Derived*)</span></span><br></pre></td></tr></table></figure>
<br/>
<br/>
<h2 id="2-2-变量作用域">2.2 变量作用域</h2>
<p>一般来说有三个地方可以定义变量：</p>
<ul>
<li>在函数或一个代码块内部声明的变量，称为<strong>局部变量</strong>。</li>
<li>在函数参数的定义中声明的变量，称为<strong>形式参数</strong>。</li>
<li>在所有函数外部声明的变量，称为<strong>全局变量</strong>。</li>
</ul>
<p>综上，每一个变量都会有自己的作用域，可以分为下面几种：</p>
<br/>
<h3 id="局部作用域">局部作用域</h3>
<p>在<strong>函数 / 代码块</strong>内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 局部变量声明</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>&#123;&#125;</code> 内部就是一个代码块，以嵌套的 <code>&#123;&#125;</code> 为标志，在当前嵌套下定义的局部变量就只能在当前的嵌套下使用 / 访问；</p>
<br/>
<h3 id="全局变量">全局变量</h3>
<p>在所有代码块外部定义的变量，称为全局变量。全局变量的值在程序的整个生命周期内都是有效的</p>
<ul>
<li>可以被程序内的任意函数 / 类访问</li>
<li>一般定义在整个程序的开头</li>
</ul>
<div class="markdown-alert markdown-alert-warning"><p class="markdown-alert-title"><svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p><p></p>
<p>注意全局变量的名称是可以和局部变量相同的，只是在局部作用域中它的访问会被局部变量替代；严禁来说就是访问 / 修改 / 删除的时候针对的都是局部变量指向的内存空间，不会对全局变量造成影响；</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a; <span class="comment">// 定义在另一个文件的外部变量，值 a = 1; 是当前文件的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> std::cout &lt;&lt; a; <span class="comment">// 输出 1;</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">2</span>; <span class="comment">// 定义了局部变量，从此当前代码块下的 a 都会变成局部变量的 a</span></span><br><span class="line"> std::cout &lt;&lt; a; <span class="comment">// 输出 2</span></span><br><span class="line"> a = <span class="number">3</span>; <span class="comment">// 此时改变的也是局部变量的 a 的值，全局变量不受影响，所以下面的 test 函数继续输出 1</span></span><br><span class="line"> <span class="built_in">test</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<br/>
<h3 id="块作用域变量">块作用域变量</h3>
<p>也就是在代码块里面定义的变量，这里的代码块用 <code>&#123;&#125;</code> 标记，可以在任意的地方使用；</p>
<p>代码块内部的变量类似局部变量，只能在当前嵌套的代码块 <code>&#123;&#125;</code> 内使用</p>
<div class="markdown-alert markdown-alert-warning"><p class="markdown-alert-title"><svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p><p></p>
<p>类似上面的局部变量，这里的块变量如果同名也会覆盖自己的上一级 <code>&#123;&#125;</code> 内定义的 &quot;全局变量&quot;，由此的调用 / 修改 / 删除都不会影响上一层的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">20</span>;  <span class="comment">// 块作用域变量</span></span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;块变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;外部变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<br/>
<h3 id="类作用域变量">类作用域变量</h3>
<p>类似地，在类的内部定义的变量称为类作用域的变量，不同点在于类作用域变量也可以在外部使用，通过 <code>classname::varname</code> 来访问；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> class_var;  <span class="comment">// 类作用域变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::class_var = <span class="number">30</span>;  <span class="comment">// 用 :: 来引用类变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类变量: &quot;</span> &lt;&lt; MyClass::class_var &lt;&lt; std::endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意同一个文件的类外部可以访问，但是跨文件使用 <code>extern</code> 声明是无法直接访问的；</p>
<br/>
<br/>
<h2 id="2-3-C-常量">2.3 C++ 常量</h2>
<p>可以理解为，程序执行中不会改变的量，也称作字面量</p>
<p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p>
<p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改</p>
<br/>
<h3 id="数值：整数常量，浮点常量">数值：整数常量，浮点常量</h3>
<p>整数常量可以是十进制、八进制或十六进制的常量</p>
<ul>
<li>0x 或 0X 表示十六进制</li>
<li>0 表示八进制</li>
<li>不带前缀则默认表示十进制</li>
</ul>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合</p>
<ul>
<li>U 表示无符号整数（unsigned）</li>
<li>L 表示长整数（long）</li>
<li>后缀可以是大写，也可以是小写，U 和 L 的顺序任意</li>
</ul>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">// 十进制</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">// 八进制 </span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">// 十六进制 </span></span><br><span class="line"><span class="number">30</span>         <span class="comment">// 整数 </span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">// 无符号整数 </span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">// 长整数 </span></span><br><span class="line"><span class="number">30ul</span>       <span class="comment">// 无符号长整数</span></span><br></pre></td></tr></table></figure>
<p>浮点常量：当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。换言之也就是其他语言中类似 <code>.5</code> 的表示在 C++ 中是无法识别的；</p>
<p>类似地，可以用 <code>e</code> 或者 <code>E</code> 表示指数；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>      <span class="comment">// 小数表示</span></span><br><span class="line"><span class="number">314159E-5</span>L   <span class="comment">// 指数表示</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="布尔常量">布尔常量</h3>
<p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<ul>
<li><strong>true</strong> 值代表真。</li>
<li><strong>false</strong> 值代表假。</li>
</ul>
<p>注意大小写，这里都是小写；</p>
<p>注意平常还是避免认定 <code>true == 1, false == 0</code>，即使有时候输出是正确的，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b = (<span class="literal">true</span> == <span class="number">1</span>);</span><br><span class="line"><span class="comment">// b 的值为 true</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="常量的自定义">常量的自定义</h3>
<p>两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器，<code>#define identifier value</code>
<ul>
<li>注意 <code>#</code> 开头的部分末尾没有分号</li>
</ul>
</li>
<li>使用 <strong>const</strong> 关键字，<code>const type variable = value;</code>
<ul>
<li>类似变量的声明的方法，常用</li>
</ul>
</li>
</ul>
<div class="markdown-alert markdown-alert-note"><p class="markdown-alert-title"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p></p>
<p>常量的变量名建议定义为全大写，注意编程规范；</p>
</div>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// #define 定义常量，注意一般写在文件的开头 (代码块 / 类的外部)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWLINE <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> area;  </span><br><span class="line">   </span><br><span class="line">   area = LENGTH * WIDTH;  <span class="comment">// 计算为 5 * 10 = 50</span></span><br><span class="line">   cout &lt;&lt; area;</span><br><span class="line">   cout &lt;&lt; NEWLINE;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// const 定义常量，此时也可以定义在类的内部，和变量声明类似</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span>  LENGTH = <span class="number">10</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span>  WIDTH  = <span class="number">5</span>;</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="type">int</span> area;  </span><br><span class="line">   </span><br><span class="line">   area = LENGTH * WIDTH;  <span class="comment">// 计算为 5 * 10 = 50</span></span><br><span class="line">   cout &lt;&lt; area;</span><br><span class="line">   cout &lt;&lt; NEWLINE;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>
<br/>
<h2 id="2-4-字符与字符串">2.4 字符与字符串</h2>
<h3 id="字符常量">字符常量</h3>
<p>字符常量：使用单引号括起来表示，</p>
<ul>
<li>默认为一个窄字符常量（例如 'x'），此时它可以存储在 <strong>char</strong> 类型的简单变量中</li>
<li>如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 <strong>wchar_t</strong> 类型的变量中</li>
<li>字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="字符串">字符串</h3>
<p>字符串常量则使用双引号括起来表示；C++ 内部提供两种风格的字符串：</p>
<br/>
<ol>
<li><strong>C 风格字符串</strong>：</li>
</ol>
<p>字符串实际上是使用 null 字符 <code>\0</code> 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 RUNOOB 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 RUNOOB 的字符数多一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char site[7] = &#123;&#x27;R&#x27;, &#x27;U&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;O&#x27;, &#x27;B&#x27;, &#x27;\0&#x27;&#125;;</span><br></pre></td></tr></table></figure>
<p>实际上，不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 <code>\0</code> 放在字符串的末尾。依据数组初始化规则，也可以把上面的语句写成以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char site[] = &quot;RUNOOB&quot;;</span><br></pre></td></tr></table></figure>
<p>以下是 C/C++ 中定义的字符串的内存表示：</p>
<img src="https://raw.githubusercontent.com/notanumbb/blog-img-hosting/main/2024/c-strings-2020-12-21-1720421771067-2.png" alt="C/C++ 中的字符串表示" style="zoom:77%;" />
<br/>
<ol start="2">
<li><strong>C++ 中的 String 类</strong></li>
</ol>
<p>基本使用包括：</p>
<ul>
<li>文件的开头加入 <code>\#include &lt;string&gt;</code>；</li>
<li>使用 <code>string varname = &quot;xxx&quot;;</code> 进行字符串变量的声明，对应 <code>&quot;xxx&quot;</code> 为一个字符串常量；</li>
<li>可以使用反斜杠 <code>\</code> 做分隔符，把一个很长的字符串常量进行分行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  <span class="comment">// 字符串类型的变量；</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string greeting = <span class="string">&quot;hello, runoob&quot;</span>; <span class="comment">// string 类型的变量 greeting，赋值为字符串常量 &quot;hello, runoob&quot;</span></span><br><span class="line">    cout &lt;&lt; greeting;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;     <span class="comment">// 换行符，这里的 \n 作为单个字符也可以用双引号; 等价于 std::cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    string greeting2 = <span class="string">&quot;hello, \</span></span><br><span class="line"><span class="string">                        runoob&quot;</span>; <span class="comment">// 使用反斜杠 \ 连接多行字符串</span></span><br><span class="line">    cout &lt;&lt; greeting2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="字符串操作基本函数">字符串操作基本函数</h3>
<p>C++ 提供了多个常用的字符串操作函数：</p>
<ul>
<li><code>string str0 = str1 + str2</code>：将两个字符串进行拼接</li>
<li>字符串的长度：
<ul>
<li>对于 C 风格的 char 数组：<code>strlen(str0);</code></li>
<li>对于 String 类的字符串：<code>str0.size()</code></li>
</ul>
</li>
</ul>
<br/>
<br/>
<h2 id="2-5-数组">2.5 数组</h2>
<p>C++ 中的数组可以理解为一个固定大小的相同类型元素的顺序集合</p>
<ul>
<li>内部的所有元素必须要是相同类型 (不同于 python 的 list)</li>
<li>数组中的特定元素通过索引来访问</li>
</ul>
<h3 id="数组声明与初始化">数组声明与初始化</h3>
<p>常用声明一个空数组的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">4</span>]; <span class="comment">// 长度为 4 的整数数组</span></span><br><span class="line"><span class="type">int</span> *arr[<span class="number">4</span>]; <span class="comment">// 长度为 4 的整数指针数组，其中每一个元素都是指向一个整型变量的指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>type</code>：指定数组内元素的类型</li>
<li><code>arraySize</code>：指定数组的大小</li>
</ul>
<p>当已知初始值时，也可以直接通过初始值来声明一个数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>注意这里的数组大小 <code>5</code> 必须大于等于给定的初始值列表的长度，如果给定的初始值列表偏短，则后面的部分留空</p>
<p>也可以不指定数组大小，此时的数组大小默认为初始值列表的长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;; <span class="comment">// 数组大小默认为 5</span></span><br></pre></td></tr></table></figure>
<p>也可以定义一个初始值为默认单一数值的数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> balance[<span class="number">50</span>] = <span class="number">0</span>;  <span class="comment">// 数组大小为 50，内部每一个元素都是 0</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="访问数组元素">访问数组元素</h3>
<p>通过索引来访问数组元素；这里的索引值从 0 开始：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> salary = balance[<span class="number">9</span>];   <span class="comment">// 访问数组元素</span></span><br><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;            <span class="comment">// 为数组中的某一个元素赋值</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="多维数组">多维数组</h3>
<p>C++ 也支持多维数组，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type name[size1][size2]...[sizeN];</span><br><span class="line"><span class="type">int</span> threedim[<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>]; <span class="comment">// 举例</span></span><br></pre></td></tr></table></figure>
<p>注意这里每一个维度内存储的数据类型也必须全部相同；</p>
<p>初始化时，可以利用嵌套的括号来进行，按照行优先 / 先填满列的顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不用嵌套括号时，也是顺次从最后一个维度开始填满，比如说</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a[3][2][2] = &#123;0,1,2,3,4,5,6,7,8,9,10,11&#125;;</span><br></pre></td></tr></table></figure>
<p>则此时 <code>0</code> 位于位置 <code>[0][0][0]</code>，<code>1</code> 位于位置 <code>[0][0][1]</code>，对应 <code>2</code> 位于位置 <code>[0][1][0]</code>，<code>3</code> 位于位置 <code>[0][1][1]</code>；以此类推</p>
<p>多维数组的索引也类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = a[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="数组与指针">数组与指针</h3>
<p>实际上，当我们定义一个数组时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> runoobArray[<span class="number">50</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>runoobArray</code> 实际上是一个指向数组第一个元素 <code>runoobArray[0]</code> 的指针；等价于 <code>&amp;runoobArray[0]</code></p>
<p>所以下面的代码是等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = runoobArray;  <span class="comment">// 将 runoobArray 的值 (= 第一个元素的地址 ) 赋值给了指针变量 p</span></span><br><span class="line">p = &amp;runoobArray[<span class="number">0</span>];  <span class="comment">// 访问 runoobArray 的第一个元素的地址 (&amp;) 然后赋值给指针变量 p</span></span><br></pre></td></tr></table></figure>
<p>这里的 p 都是一个指向了 <code>runoobArray</code> 第一个元素的指针；</p>
<p>因此，我们也可以通过指针的方式来访问数组内的元素；下面的代码等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret;</span><br><span class="line">ret = *(runoobArray + <span class="number">4</span>);</span><br><span class="line">ret = runoobArray[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>当然也可以通过这样的方式来进行赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(runoobArray + <span class="number">2</span>) = <span class="number">500</span>;</span><br></pre></td></tr></table></figure>
<div class="markdown-alert markdown-alert-warning"><p class="markdown-alert-title"><svg class="octicon octicon-alert mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p><p></p>
<p>然而，注意虽然上述的数组名 <code>runoobArray</code> 属于指针，但对它进行重新赋值 / 更改是非法的，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = runoobArray;</span><br><span class="line">p ++;  <span class="comment">// success</span></span><br><span class="line">runoobArray ++; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>换言之，可以通过 <code>(runoobArray + 1)</code> 来进行 &quot;访问&quot;，但过程中不能改变 <code>runoobArray</code> 本身，例如 <code>runoobArray = runoobArray + 1</code> 就是违法的；</p>
</div>
<br/>
<br/>
<h2 id="2-6-struct-自定义数据结构">2.6 <code>struct</code> 自定义数据结构</h2>
<p>可以利用 <code>struct</code> 语句来定义一个新的数据结构</p>
<h3 id="定义与访问">定义与访问</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type_name</span> &#123;</span><br><span class="line">member_type1 member_name1 = <span class="keyword">default</span>;</span><br><span class="line">member_type2 member_name2;</span><br><span class="line">member_type3 member_name3 = <span class="keyword">default</span>;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type_name</code>：新定义的数据结构的名称</li>
<li><code>member_type1 member_name1</code>：也就是传统的变量声明的结构，这里的 <code>type</code> 需要是已经存在的数据类型</li>
<li><code>default</code> 注明当前成员的默认值，可选；</li>
<li>注意结构体定义结束最后的分号；</li>
</ul>
<p>定义后可以通过 <code>.</code> 来访问结构体内的成员，比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type_name var;  <span class="comment">// 声明一个数据类型为自定义 `type_name` 的变量，变量名为 `var`</span></span><br><span class="line"><span class="type">int</span> a = var.member_name1;  <span class="comment">// 获取名为 `member_name1` 的成员</span></span><br></pre></td></tr></table></figure>
<p>来举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 声明一个结构体类型 Books </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Books Book1;             <span class="comment">// 定义结构体类型 Books 的变量 Book1</span></span><br><span class="line">   Book1.book_id = <span class="number">12345</span>;   <span class="comment">// 访问成员 book_id 并赋值</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>
<h3 id="作为函数参数">作为函数参数</h3>
<p>类似地，也可以将上面自定义的数据类型 <code>Books</code> 的变量传递给函数，</p>
<p>基本操作如下，注意这里的 <code>struct Books</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span> </span>&#123;...&#125;  <span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">( <span class="keyword">struct</span> Books book )</span></span>;       <span class="comment">// 函数声明</span></span><br><span class="line">Books book1;                               <span class="comment">// 声明 Books 类型的新变量</span></span><br><span class="line"><span class="built_in">printBook</span>( Book1 );                        <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure>
<br/>
<h3 id="指向自定义结构的指针">指向自定义结构的指针</h3>
<p>也可以定义一个指向 <code>struct</code> 结构的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个结构体类型 Books </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">int</span>   book_id = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Books Book1;  <span class="comment">// Books 是结构体 / 自定义数据结构名称，Book1 是类型为 Book 的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span>* struct_pointer;   <span class="comment">// 声明指针;</span></span><br><span class="line">struct_pointer = &amp;Book1;        <span class="comment">// 为指针赋值为变量地址;</span></span><br></pre></td></tr></table></figure>
<p>对于一个指向 <code>struct</code> 结构的指针，可以通过 <code>-&gt;</code> 来访问成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer-&gt;title;   <span class="comment">// 使用 -&gt; 直接访问</span></span><br><span class="line">(*struct_pointer).title; <span class="comment">// 等价，也可以先通过 * 访问指针指向的对象，再用 . 访问成员</span></span><br></pre></td></tr></table></figure>
<br/>
<br/></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/notanumbb">notanumbb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>本文链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/28/note/code/note-cpp-runoob-2/">http://example.com/2024/06/28/note/code/note-cpp-runoob-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">文章采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/nisepanda_round.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">notanumbb</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/notanumbb" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:notanumbb@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://weibo.com/u/7903578872" target="_blank" title="weibo"><i class="fa-brands fa-weibo" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn"></i><span>in progress</span></div><div class="announcement_content">我感觉 abtest 的 ab 是 abuse 的 ab
最近很沮丧
  [now playing] triangle strategy
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">2.1 基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">七种基础数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC"><span class="toc-text">左值与右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%9A%E9%87%8D%E5%91%BD%E5%90%8D%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">自定义：重命名与枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2.2 变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">局部作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%98%E9%87%8F"><span class="toc-text">块作用域变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%98%E9%87%8F"><span class="toc-text">类作用域变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-C-%E5%B8%B8%E9%87%8F"><span class="toc-text">2.3 C++ 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%EF%BC%9A%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%EF%BC%8C%E6%B5%AE%E7%82%B9%E5%B8%B8%E9%87%8F"><span class="toc-text">数值：整数常量，浮点常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%B8%B8%E9%87%8F"><span class="toc-text">布尔常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="toc-text">常量的自定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2.4 字符与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"><span class="toc-text">字符常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-text">字符串操作基本函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%95%B0%E7%BB%84"><span class="toc-text">2.5 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">数组声明与初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">访问数组元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-text">数组与指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-struct-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">2.6 struct 自定义数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AE%BF%E9%97%AE"><span class="toc-text">定义与访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">指向自定义结构的指针</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By notanumbb</div><div class="framework-info"><span>Powered by </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div></div></body></html>